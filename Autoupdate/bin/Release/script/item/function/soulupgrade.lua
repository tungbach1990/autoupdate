
-- 印鉴属性升级
-- zhengyuhua

-- define

Item.SOULUPGRADE_EXP_PER_ITEM		= 100;				-- 每个魂石头的经验
Item.SOULUPGRADE_ITEM_CLASS			= "spiritstore"		-- 魂石Classname
Item.SOULUPGRADE_EQUIP_CLASS		= "soulsignet"			-- 印章Classname

----------------------------------------------------------------------

function Item:SetSoulSignetMagic(pSignet, nMagicIndex, nLevel, nExp)
	pSignet.SetGenInfo(nMagicIndex * 2 - 1, nLevel);
	pSignet.SetGenInfo(nMagicIndex * 2, nExp);
	local nRet = pSignet.Regenerate(
		pSignet.nGenre,
		pSignet.nDetail,
		pSignet.nParticular,
		pSignet.nLevel,
		pSignet.nSeries,
		pSignet.nEnhTimes,
		pSignet.nLucky,
		pSignet.GetGenInfo(),
		0,
		pSignet.dwRandSeed,
		0
	);
end

function Item:CalcSoulUpgrade(pSignet, nMagicIndex, nItemNum)
	if not pSignet or pSignet.szClass ~= self.SOULUPGRADE_EQUIP_CLASS then
		return 0;
	end
	if nMagicIndex <= 0 or nMagicIndex > self.SOULSIGNET_ATTRIB_NUM then
		return 0;
	end
	local nLevel 	= pSignet.GetGenInfo(nMagicIndex * 2 - 1, 0);
	local nExp		= pSignet.GetGenInfo(nMagicIndex * 2, 0);
	
	-- 根据五行印的不同，属性等级的上限也不同
	local nLevelMax = self.tbMAX_SOULSIGNET_LEVEL[pSignet.nLevel or 1][nMagicIndex];
	
	
	nExp = nExp + math.floor(nItemNum * self.SOULUPGRADE_EXP_PER_ITEM / 100);
	local tbSetting = Item:GetExternSetting("soulsignet", pSignet.nVersion);
	if nLevel < self.MIN_SOULSIGNET_LEVEL then
		return 0;
	end
	while (nLevel < nLevelMax and nExp >= tbSetting["m_LevelExp"..nMagicIndex][nLevel]) do
		nExp = nExp - tbSetting["m_LevelExp"..nMagicIndex][nLevel];
		nLevel = nLevel + 1;
	end
	local nResCount = 0;
	-- 如果等级到达上限后，还有多余的经验，把这些经验转成魂石个数返还给玩家
	if nLevel >= nLevelMax and  nExp > 0 then
		nResCount = math.floor(nExp / (self.SOULUPGRADE_EXP_PER_ITEM / 100));
	end
	return nLevel, nExp, tbSetting["m_LevelExp"..nMagicIndex][nLevel] or 0, nResCount;
end

-- 升级五行印  
-- 		参数说明：pSignet:五行印指针，tbUpgradeItem:放在升级栏的道具，nMagicIndex:选择要升级的属性
function Item:UpgradeSoulSignet(pSignet, tbUpgradeItem, nMagicIndex)
	if not pSignet or pSignet.szClass ~= self.SOULUPGRADE_EQUIP_CLASS then
		return 0;
	end

	-- 根据五行印的不同，属性等级的上限也不同
	local nLevelMax = self.tbMAX_SIGNET_LEVEL[pSignet.nLevel or 1];
	local nItemNum = 0;
	for _, pItem in pairs(tbUpgradeItem) do
		if pItem.szClass == self.UPGRADE_ITEM_CLASS then	-- 检查是否是魂石
			local nCurCount = pItem.nCount;
			local nLevel, nExp, _, nResCount = self:CalcSoulUpgrade(pSignet, nMagicIndex, nCurCount);
			local nRet = 0;
			if nResCount > 0 then
				nRet = pItem.SetCount(nResCount, Item.emITEM_DATARECORD_REMOVE);
			elseif nResCount == 0 then
				nRet = me.DelItem(pItem, Player.emKLOSEITEM_SERIES_STONE);		-- 扣除魂石
			end
			if nRet ~= 1 then
				Dbg:WriteLog("Upgrade", "角色名:"..me.szName, "帐号:"..me.szAccount, "扣除魂石失败！叠加数:", nCurCount);
			else
				nItemNum = nItemNum + nCurCount;
				self:SetSoulSignetMagic(pSignet, nMagicIndex, nLevel, nExp);
			end
			if nLevel >= nLevelMax then -- 升级到极限了
				break;
			end
		else
			Dbg:WriteLog("Upgrade", "角色名:"..me.szName, "帐号:"..me.szAccount, "尝试混入非魂石道具升级五行印")
		end
	end
	if nItemNum == 0 then
		return 0;
	end

	return 1;
end

function Item:UpgradeSoulSignetNoItem(pSignet, nCurCount, nMagicIndex)
	if not pSignet or pSignet.szClass ~= self.SOULUPGRADE_EQUIP_CLASS then
		return 0;
	end

	-- 根据五行印的不同，属性等级的上限也不同
	local nLevelMax = self.tbMAX_SOULSIGNET_LEVEL[pSignet.nLevel or 1][nMagicIndex];

	local nLevel, nExp, _, nResCount = self:CalcSoulUpgrade(pSignet, nMagicIndex, nCurCount);
	print(nLevel,nExp,nResCount,nMagicIndex);
	if nLevel >= nLevelMax then -- 升级到极限了
		nExp=0;
	end
	local nRet = self:SetSoulSignetMagic(pSignet, nMagicIndex, nLevel, nExp);

	return nResCount; -- 返回保留数量
end
